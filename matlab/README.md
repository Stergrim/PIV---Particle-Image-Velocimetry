# Документация проекта
Здесь приведена неформальная документация по коду и функциональная блок-схема.
Очередность использования модулей (методов) не строгая, возможно использовать в
другом порядке. Это только рекомендация к очередности модулей.

 <img src="/demos/FunctionSchema.png" width="400" />|<img src="/demos/FunctionSchemaAdd.png" width="300" /> 
|:--------------------------------------------------|-----------------------------------------------------:|

Описание модулей: <br>
**1.** `Storage` <br>
Класс хранения данных обработки. Через него осуществляется взаимодействие и
передача данных между функциями. <br>
Свойства (поля): <br>
`src_image_1` – первое исходное изображении <br>
`src_image_2` – второе исходное изображении <br>
`image_1` – первое обрабатываемое изображение <br>
`image_2` – второе обрабатываемое изображение <br>
`window_size` – размер окна опроса `[height, width]` <br>
`overlap` – величина наложения окон опроса `[height, width]` <br>
`centers_map` – матрица центров окон опроса на первом изображении <br>
&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;`X = centers_map( : , : ,1)`; (столбцы `j`) <br>
&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;`Y = centers_map( : , : ,2)`; (строки `i`) <br>
`vectors_map` – векторное поле <br>
&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;`U = vectors_map( : , : ,1)` <br>
&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;`V = vectors_map( : , : ,2)` <br>
`outliers_map` – маска выбросов <br>
&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;`0` – выброс отсутствует <br>
&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;`1` – выброс <br>
`replaces_map` – маска замещенных векторов <br>
&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;`0` – вектор не замещен <br>
&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;`1` – интерполирован <br>
&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;`2` – замена 2-м корреляционным пиком <br>
&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;`3` – замена 3-м корреляционным пиком <br>
`correlation_maps` – коллекция хранящая корреляционный карты <br>
&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;`corr_map = correlation_maps{i, j}` <br>
`vectors_map_last_pass` – векторное поле последнего прохода <br>

**2.** `load_images(Storage, image_address_1, image_address_2)` <br>
Загрузка пары изображений в класс `Storage`. Поддерживаемые
форматы **jpg, jpeg, png, tif**.

**3.** `preprocessing(Storage)` <br>
Предобработка изображений. Выполняет перевод из цветного в черно-белое
изображение и приведение к типу данных **double**. Записывает
предобработанные изображения в класс `Storage`.

**4.** `pass(Storage, window_size, overlap, varargin)` <br>
Расчет векторного поля кросскорреляционным методом. В зависимости от
заданных параметров может работать, как проход для получения первичного
векторного поля, так и проход для уточнения существующего векторного поля. <br>

| `varargin`                                                                                                                                                                  |
|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `‘type_pass’` – тип прохода <br> `type_pass` = `‘first’` или `‘next’`                                                                                                       |
| `‘double_corr’` = `true/false` – перемножение соседних корреляционных карт <br> `direct` = `‘x’`, `‘y’`, `‘xy’`, `‘center’` – метод перемножение                            |
| `‘restriction’` = `true/false` – ограничение области поиска корреляционного пика <br> `restriction_area` = `‘1/4’`, `‘1/3’`, `‘1/2’` – величина ограничения от размера окна |
| `‘deform’` = `true/false` – деформация изображений <br> `deform¬_type` = `‘symmetric‘` или `‘second’` – тип деформации                                                      |
| `‘borders’` – обработка границ изображений <br> `borders` = `true/false`                                                                                                    |

Основные задачи разбить изображения на окна опроса, произвести кросскорреляцию
окон опроса и найти максимумы кросскорреляции. <br>
Опции: <br>
- Мультисеточный метод (`multigrid`), включается если в проходе изменить размеры (`windows_size`) или наложение (`overlap`) окон опроса относительно предыдущего прохода. <br>
- Деформация изображений (окон опроса) (`deform`). <br>
- Перемножение соседних корреляционных карт (`double_corr`) для уменьшения влияния шумов. <br>
- Ограничение области поиска корреляционного пика (`restriction`) для уменьшения количества ошибочных векторов, но жертвуем максимальной разрешаемой величиной вектора смещения. <br>
- Обработка, включая границы изображения (`borders`). <br>

**4.1** `[X0, Y0] = images_split(Storage, type_pass, multigrid, borders)` <br>
Выполняет расчет координат окон опроса без учета векторного поля. <br>
Если `type_pass = ‘first’` или `multigrid = true`, то рассчитывается координаты окн опроса.
Иначе в выходные аргументы записываются значения из предыдущего
прохода (`Storage.centers_map`). <br>
`[X0, Y0]` – координаты начала окон опроса на первом изображении. За начала окна
опроса берется верхний левый угол окна опроса. <br>
Параметр `borders` позволяет заполнить окнами опроса остаточные границы, если
не поместилось кратное размеру изображения количество окон опроса по
вертикали или горизонтали. При этом граничные окна опроса будут иметь
другую величину наложения (`overlap`).

**4.2** `deform_images(Storage, deform_type)` <br>
Деформация изображений в соответствии с векторным полем последнего прохода. <br>
Имеется два типа деформации: <br>
`‘symmetric’` – два изображения деформируются симметрично друг на встречу другу; <br>
`‘second’` – только второе изображение деформируется навстречу к первому изображению.

**4.3** `resize_field(Storage, size_map)` <br>
Масштабирование векторного поля с предыдущего прохода в соответствии с новыми
размерами (`windows_size`) и наложением (`overlap`) окон опроса.

**4.4** `cross_correlate(Storage, size_map, X0, Y0, type_pass, deform, double_corr)` <br>
Кросскорреляция окон опроса. Используется встроенная функция ***Matlab*** `normxcorr2`. <br>
Если `type_pass = ‘first’` или `deform = true`, то окна опроса на втором изображении
не смещаются относительно первого. Иначе на втором изображении окна опроса
смещаются в соответствии с векторным полем (`Storage.vectors_map`). В случае
выхода окон опроса на втором изображении за пределы изображения производится
их смещение внутрь до границы изображения. <br>
Добавлена обработка ошибки функции `normxcorr2`
`‘images:normxcorr2:sameElementsInTemplate’`, которая возникает в
случае однородности окна опроса, то есть одинаковые яркости во всех
пикселях внутри окна опроса. В таком случае вектор смещения, принадлежащий
окну опроса, записывается в выбросы, а корреляционная карта заполняется нулями
или если выбрана опция перемножения соседних корреляционных карт (`double_corr`),
то единицами.

**4.5** `double_correlate(Storage, direct)` <br>
Перемножение соседних корреляционных карт. Уменьшает случайный шум на
корреляционных картах. Эффективно в случае небольшого отклонения соседних векторов.

**4.6** `search_peak(Storage, size_map, restriction, restriction_area)` <br>
Поиск корреляционного пика (максимума), что является вектором смещения. Для
выбросов, определенных в функции `cross_correlate`, вектор смещения
приравнивается к нулю.

**5.** `[varargout] = peak_filter(Storage, varargin)` <br>
Проверка на выброс по величине корреляционного пика. <br>
Возможно проверить отдельный вектор по его координатам.

| `varargin`                                                                                                   |
|:-------------------------------------------------------------------------------------------------------------|
| `‘threshold’` – порог фильтрации <br> `threshold` = `(double)`                                               |
| `‘single’` = `true/false` – проверить отдельный вектор <br> `[i ,j]` = `[(int),(int)]` – координаты вектора  |

`varargout` = `true/false` – в случае проверки отдельного вектора.

**6.** `[varargout] = validate_outliers(Storage, varargin)` <br>
Поиск выбросов нормализованным медианным тестом. <br>
Возможно проверить один конкретный вектор, а также задать свои параметры расчета.

| `varargin`                                                                                                  |
|:------------------------------------------------------------------------------------------------------------|
| `‘radius’` – радиус окрестности <br> `r` = `(int)`                                                          |
| `‘threshold’` – порог флуктуации <br> `threshold` = `(double)`                                              |
| `‘noise’` – уровень шума при измерениях <br> `noise` = `(double)`                                           |
| `‘borders’` – проверка границ поля <br> `borders` = `true/false`                                            |
| `‘single’` = `true/false` – проверить отдельный вектор <br> `[i ,j]` = `[(int),(int)]` – координаты вектора |

`varargout` = `true/false` – в случае проверки отдельного вектора.

**7.** `replace_outliers_next_peak(Storage, varargin)` <br>
Замена выбросов 2 и 3 корреляционным пиком. <br>
Возможно задать ограничение области поиска корреляционного пика.

| `varargin`                                                                                                                                                                  |
|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `‘restriction’` = `true/false` – ограничение области поиска корреляционного пика <br> `restriction_area` = `‘1/4’`, `‘1/3’`, `‘1/2’` – величина ограничения от размера окна |

Сначала производится замена 2-ым корреляционным пиком всех выбросов и
проверяются заменённые вектора нормализованным медианным
тестом (`validate_outliers`). Если какие-то вектора оказались выбросами, то
они заменяются 3-им корреляционным пиком и снова проверяются. Те что не
прошли проверку возвращаются к исходному состоянию. В случае
замены 2-ым корреляционным пиком в маску замещенных
векторов (`Storage.replaces_map`) записывается значение `2`, в случае 3-им `3`: <br>
`Storage.replaces_map(i, j) = 2`, <br>
`Storage.replaces_map(i, j) = 3`.

**8.** `interpolate_outliers(Storage, varargin)` <br>
Замена выбросов медианным значение окрестности.

| `varargin`                                        |
|:--------------------------------------------------|
| `‘radius’` – радиус окрестности <br> `r` = `(int)`|

Интерполяция повторяется до тех пор, пока все замененные вектора не
пройдут проверку нормализованным медианным тестом (`validate_outliers`) или
достигнем предела количества итераций. В случае успешной замены в
маску замещенных векторов (`Storage.replaces_map`) записывается
значение `1`: <br>
`Storage.replaces_map(i, j) = 1`.

**9.** `smoothing(Storage)` <br>
Сглаживание векторного поля. Улучшает гладкость векторного поля. <br>
Не рекомендуется использовать на финальном проходе и перед субпиксельным
уточнением (`subpixel_peak`).

**10.** `subpixel_peak(Storage, varargin)` <br>
Уточнение корреляционного пика с субпиксельной точностью.

| `varargin`                                        |
|:--------------------------------------------------|
| `‘method’` – метод 3-ех точеной аппроксимации <br> `method` = `‘gaussian’`, `‘centroid’`, `‘parabolic’`|

Интерполированные вектора не обрабатываются (`Storage.replaces_map = 1`).
Если есть желание использовать этот метод на не целые значения векторного
поля, например, после сглаживания векторного поля (`smoothing`), то необходимо
округлять до целого значения смещения (`x_peak, y_peak`).

**11.** `show(Storage)` <br>
Визуализатор результатов обработки.

**12.** `read_flow_file(Storage, filename)` <br>
Чтение векторный карты из **.flo**  файла и запись в класс `Storage`.

**13.** `write_flow_file(Storage, filename, varargin)` <br>
Записывает векторное поле из класса `Storage` в **.flo** файл. <br>
Возможно масштабирование векторного поля перед записью в файл.

| `varargin`                                                |
|:----------------------------------------------------------|
| `‘scaling’` = `true/false` – масштабирование векторного поля  |

Рекомендуется использовать вместе параметром `‘scaling’`, который
отвечает за масштабирование векторного поля до размера изображения
(вектор на пиксель). Так как **flow** файл предполагает, что плотность
векторного поля соответствует размеру изображения и поэтому не содержит
информации о начале вектора (`Storage.centers_map`).

**14.** `main` <br>
Пример работы программы с визуализацией результатов и примеры различных
сценариев обработки.

**15.** `processing_1(Storage), processing_2(Storage) … processing_5(Storage)` <br>
Сценарии (процедуры) обработки изображений. <br>
Примеры возможных процедур: <br>
`processing_1` – однопроходный сценарий, <br>
`processing_2` – трехпроходный сценарий, <br>
`processing_3` – трехпроходный сценарий с деформацией изображений, <br>
`processing_4` – четырехпроходный сценарий, <br>
`processing_5` – четырехпроходный сценарий с деформацией изображений.

**16.** `test_processing` <br>
Скрипт тестирования заданного сценария обработки на 5-ти парах
изображений с различными видами потока.

**16.1** `div_vec = get_compared(Storage, procedure, image_address_1, image_address_2, visual_map, visual_bar, varargin)` <br>
Сравнение заданного векторного поля с результатом обработки. <br>
Находит среднеарифметическое модуля отклонения двух полей и
максимум отклонения по одной из координат. <br>
Среднеарифметическое модуля отклонений рассчитывается по следующей формуле:

$$ \displaystyle\ mean = \frac{\sum [|x-x_0|+|y-y_0|]}{2\times H\times W} $$

где `H`, `W` – размеры векторного поля.

**17.** `group_test` <br>
Скрипт тестирования группы сценариев обработки на наборе данных. <br>
Позволяет получить данные о среднеквадратическом и максимуме
отклонений векторных полей для списка сценариев обработки на наборе данных.
В каталоге набора данных должны иметься flow файлы с истинным полем и пары
изображений, отсортированные так, чтобы они соответствовали flow файлам и пара
изображений шла друг за другом, пример в каталоге [demos/group_test](/demos/group_test).

**17.1** `data = get_compared_group(Storage, folder_address, image_format, processing_vec)` <br>
Сравнение заданного векторного поля с результатами обработок сценариев. <br>
Находит среднеквадратическое модуля отклонения двух полей и максимум отклонения. <br>
Среднеквадратическое отклонений рассчитывается по следующей формуле:

$$ \displaystyle\ RMS = \sqrt\frac{\sum [(x-x_0)^2+(y-y_0)^2]}{H\times W (H\times W - 1)} $$

где `H`, `W` – размеры векторного поля.

**17.2** `build_graphs_group(data)` <br>
Визуализация результатов сравнения для всех сценариев. Позволяет
визуализировать динамическое число сценариев.
